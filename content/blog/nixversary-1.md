---
draft: true
date: 2025-12-11T12:50:00
title: Celebrating My First Nixversary
description: What a year of Nix, Nixpkgs, Flakes, and Home-Manager has been for me
---
Last week I crossed the 1 year mark since I started using Nix in some way or other, and I wanted to take a moment to reflect and appreciate what a positive experience it has been. What started off as a little curiosity has now become a lifeline — a tool that actively boosts my productivity, and allows me to focus on what’s important. It’s also been impactful in helping me understand how my system works, and cutting down unnecessary bloat.

On Linux land, I was used to doing \`apt install\` or \`pacman -Syy\` commands for package management. Since getting a Mac that changed to \`brew install\`, but the flow remained the same — and so did the drawbacks. Run a command, install software, if you don’t use it then forget it exists. The more software you install, the harder it gets to prune. You start hoarding packages like paper rolls during COVID. Mid-to-late 2024 I was looking for ways to lighten up my Mac, after several system warnings about my measly 256GB of storage filling up. Nix promised a solution — declarative configs; you know exactly what’s installed, and installing new programs requires you to type it out so you have time to reconsider if you really need it. I was sold.

Here, a little Nix primer may be appropriate for readers unfamiliar with its ecosystem. Nix is not a single software but a variety of interconnected things. There’s Nix the functional programming language, for Nix the declarative package manager, around which NixOS the Linux distribution was built. For macOS there’s Nix-Darwin and community projects like Nix-Homebrew. For user configuration management there’s Home Manager. And to make it more confusing than it already is, there’s two paradigms of package management via Nix — channels and flakes. Flakes use lockfiles to pin versions, while channels does no such thing — you either accept the lack of full reproducibilit, or use community-supported version pinning systems like npins. Flake has its own drawbacks, like copying the entire source tree to the Nix Store every time. And yes, Nix Store is another Nix thing; it’s the volume where Nix stores its artifacts (software, configs, etc.), which is different from the Filesystem Hierarchy Standard (FHS) we see in most other forms of package management. Now back to my Nix journey.

Became the maintainer of Meta’s Pyrefly (Python type checker and LSP) package on Nixpkgs. Made PR (awaiting review) to add and maintain Huggingface’s Git-Xet package. Crafted a multi-machine, multi-platform config with shared modules. Maintaining a personal Nix package and module set for stuff I find interesting but don’t quite want to commit to maintaining in upstre Nixpkgs.
